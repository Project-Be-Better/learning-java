# Java Programming Refresher

A comprehensive guide to Java fundamentals, covering essential concepts, syntax, and best practices.

## Table of Contents

- [Basic Java Commands](#basic-java-commands)
- [File Extensions](#file-extensions)
- [Understanding main Method](#understanding-main-method)
- [Reserved Keywords](#reserved-keywords)
- [Comments](#comments)
- [Variables and Data Types](#variables-and-data-types)
- [Value Types vs Reference Types](#value-types-vs-reference-types)
- [Stack vs Heap Memory](#stack-vs-heap-memory)
- [Incrementing Operations](#incrementing-operations)
- [Strings](#strings)
- [Pass-by-Value vs Pass-by-Reference](#pass-by-value-vs-pass-by-reference)
- [Practice Code Examples](#practice-code-examples)

## Basic Java Commands

| Command         | Description                                                          | Example / Usage         |
| --------------- | -------------------------------------------------------------------- | ----------------------- |
| `javac`         | Compiles Java source code into bytecode                              | `javac HelloWorld.java` |
| `java`          | Runs compiled Java bytecode                                          | `java HelloWorld`       |
| `java -version` | Displays the version of the installed Java Runtime Environment (JRE) | `java -version`         |
| `java -help`    | Displays help and usage information for Java command-line tools      | `java -help`            |

## File Extensions

### .java Extension

- Represents Java source files
- Contains human-readable Java code that you write
- Must be compiled using `javac` before running
- üìÅ Example: `HelloWorld.java`

> **Note:** It will not flag compilation error for logical errors

### .class Extension

- Represents compiled Java bytecode
- Generated by the Java compiler (`javac`)
- Contains machine-readable instructions understood by the Java Virtual Machine (JVM)
- üìÅ Example: `HelloWorld.class`

## Understanding main Method

### `public static void main(String[] args)`

| Keyword  | Description                                                                                           |
| -------- | ----------------------------------------------------------------------------------------------------- |
| `public` | An access modifier that allows the method to be accessible from anywhere                              |
| `static` | Indicates the method belongs to the class, not to instances. Can be called without creating an object |
| `void`   | Specifies the method does not return any value                                                        |
| `main`   | The entry point of any Java program. The JVM looks for this method to start execution                 |

### Additional Notes

- The full method signature **`public static void main(String[] args)`** is required for execution
- `String[] args` is used to receive command-line arguments passed during program execution
- The Java Virtual Machine (JVM) invokes this method automatically when a Java application is launched

## Reserved Keywords

| Keyword        | Description                                                               |
| -------------- | ------------------------------------------------------------------------- |
| `abstract`     | Specifies that a class or method will be implemented later, in a subclass |
| `assert`       | Used for debugging purposes                                               |
| `boolean`      | Declares a variable as a boolean type                                     |
| `break`        | Exits from the loop or switch statement                                   |
| `byte`         | Declares a variable as a byte type                                        |
| `case`         | Defines a group of statements to execute in a switch statement            |
| `catch`        | Catches exceptions generated by try statements                            |
| `char`         | Declares a variable as a character type                                   |
| `class`        | Declares a class                                                          |
| `const`        | Not used. Reserved for future use                                         |
| `continue`     | Skips the current iteration of a loop and proceeds to the next iteration  |
| `default`      | Specifies the default block of code in a switch statement                 |
| `do`           | Starts a do-while loop                                                    |
| `double`       | Declares a variable as a double type                                      |
| `else`         | Specifies the block of code to execute if the condition is false          |
| `enum`         | Declares an enumerated (enum) type                                        |
| `extends`      | Indicates that a class is inherited from another class                    |
| `final`        | Defines an entity once that cannot be changed or inherited later          |
| `finally`      | Executes a block of code after try-catch, regardless of the outcome       |
| `float`        | Declares a variable as a float type                                       |
| `for`          | Starts a for loop                                                         |
| `goto`         | Not used. Reserved for future use                                         |
| `if`           | Tests a condition                                                         |
| `implements`   | Indicates that a class implements an interface                            |
| `import`       | Imports other Java packages or classes                                    |
| `instanceof`   | Tests whether an object is an instance of a class                         |
| `int`          | Declares a variable as an integer type                                    |
| `interface`    | Declares an interface                                                     |
| `long`         | Declares a variable as a long type                                        |
| `native`       | Specifies that a method is implemented in native code using JNI           |
| `new`          | Creates new objects                                                       |
| `null`         | Represents a null value                                                   |
| `package`      | Declares a package                                                        |
| `private`      | Specifies that a member is accessible only within its own class           |
| `protected`    | Specifies that a member is accessible within its package and subclasses   |
| `public`       | Specifies that a member is accessible by any other class                  |
| `return`       | Exits from the current method and optionally returns a value              |
| `short`        | Declares a variable as a short type                                       |
| `static`       | Specifies that a member belongs to the class, rather than instances of it |
| `strictfp`     | Restricts floating-point calculations to ensure portability               |
| `super`        | Refers to the superclass of the current object                            |
| `switch`       | Starts a switch statement                                                 |
| `synchronized` | Specifies that a method or block of code is synchronized                  |
| `this`         | Refers to the current object                                              |
| `throw`        | Throws an exception                                                       |
| `throws`       | Declares the exceptions that a method can throw                           |
| `transient`    | Prevents serialization of a member                                        |
| `try`          | Starts a block of code that will be tested for exceptions                 |
| `void`         | Specifies that a method does not return a value                           |
| `volatile`     | Indicates that a variable may be changed unexpectedly                     |
| `while`        | Starts a while loop                                                       |

## Comments

### What are Comments?

Comments are non-executable parts of the code used to:

- Explain logic
- Leave notes for yourself or other developers
- Temporarily disable code for testing

The Java compiler ignores comments.

### Types of Java Comments

| Type          | Syntax                               | Use Case                                    |
| ------------- | ------------------------------------ | ------------------------------------------- |
| Single-line   | `// This is a comment`               | For short, inline explanations              |
| Multi-line    | `/* This is a multi-line comment */` | For longer explanations or code block notes |
| Documentation | `/** This generates Javadoc */`      | To document classes, methods, and APIs      |

### Examples

#### Single-line comment

```java
int age = 30; // stores user age
```

#### Multi-line comment

```java
/* This method calculates
   the user's final score */
public int calculateScore() { ... }
```

#### Documentation (Javadoc) comment

```java
/**
 * Adds two integers and returns the result.
 * @param a First number
 * @param b Second number
 * @return Sum of a and b
 */
public int add(int a, int b) {
    return a + b;
}
```

### Pro Tips

- Don't over-comment: Good code should mostly speak for itself
- Use comments to explain **why**, not just **what**
- Keep comments up to date with your code changes
- Javadoc is extremely useful for API documentation ‚Äî use it consistently

### Common Interview Insight

**"What's the difference between `//`, `/* */`, and `/** \*/` in Java?"\*\*

- `//` is for quick, single-line notes
- `/* */` is for temporary code disabling or multi-line thoughts
- `/** */` creates Javadoc, which can be exported as HTML documentation using the javadoc tool

## Variables and Data Types

### What Are Variables?

A variable is a named memory location used to store data during program execution.

**Syntax:**

```java
<data_type> <variable_name> = <value>;
```

### Java Primitive Data Types

| Data Type | Size   | Default Value | Example Code           | Description                                                                       |
| --------- | ------ | ------------- | ---------------------- | --------------------------------------------------------------------------------- |
| `byte`    | 8-bit  | 0             | `byte b = 100;`        | 8-bit signed two's complement integer. Range: -128 to 127                         |
| `short`   | 16-bit | 0             | `short s = 1000;`      | 16-bit signed two's complement integer. Range: -32,768 to 32,767                  |
| `int`     | 32-bit | 0             | `int i = 100000;`      | 32-bit signed integer. Most commonly used whole number type                       |
| `long`    | 64-bit | 0L            | `long l = 100000L;`    | 64-bit signed integer. Ends with L                                                |
| `float`   | 32-bit | 0.0f          | `float f = 10.5f;`     | Single-precision 32-bit IEEE 754 floating point. Ends with f                      |
| `double`  | 64-bit | 0.0d          | `double d = 10.5;`     | Double-precision 64-bit IEEE 754 floating point. Default type for decimals        |
| `boolean` | 1-bit  | false         | `boolean flag = true;` | Represents true or false logic                                                    |
| `char`    | 16-bit | '\u0000'      | `char c = 'A';`        | Single 16-bit Unicode character. Stored as numbers (e.g., ASCII codes) internally |

### Variable Naming Rules

- Must start with a letter, `_`, or `$`
- Cannot start with a number
- Case-sensitive (`age` ‚â† `Age`)
- Avoid using Java reserved keywords (e.g., `int`, `class`)
- Recommended: camelCase for variables ‚Üí `userAge`, `totalCount`

### Pro Tips

- Use `int` instead of `byte` or `short` unless memory is critical
- Use `double` over `float` for precision unless required
- Use `boolean` and `char` thoughtfully ‚Äî they can optimize logic and memory
- Always initialize variables if you're not sure about the default value

### Interview Flashcard

**What's the difference between float and double?**

- `float` is 32-bit, single precision (less accurate)
- `double` is 64-bit, double precision (more accurate)
- Always use `f` with float literals: `float f = 3.14f;`

## Value Types vs Reference Types

### Java Type System Overview

Java divides types into two broad categories:

- **Value Types**: Primitive types like `int`, `float`, `boolean`
- **Reference Types**: Non-primitive types like `String`, arrays, classes, interfaces, and enums

These categories behave differently in terms of memory allocation, assignment, and method parameter passing.

### Value Types (Primitive Types)

Value types are the 8 Java primitives:

- `byte`, `short`, `int`, `long`
- `float`, `double`
- `char`
- `boolean`

**Characteristics:**

- Stored directly in the stack
- Hold the actual value
- Fast access, small memory footprint
- When assigned or passed to methods, the value is copied
- Each variable holds an independent copy

**Example:**

```java
int a = 10;
int b = a;
b = 20;
System.out.println(a); // prints 10
```

Here, `b` gets a copy of `a`'s value. Changing `b` does not affect `a`.

### Reference Types (Objects, Arrays, etc.)

Reference types include all class-based types such as:

- Objects (`String`, `ArrayList`, user-defined classes)
- Arrays
- Interfaces
- Enums

**Characteristics:**

- The reference (pointer) is stored in the stack
- The actual object is stored in the heap
- When assigned or passed to methods, the reference is copied, not the object itself
- Multiple variables can point to the same object in memory

**Example:**

```java
int[] x = {1, 2, 3};
int[] y = x;
y[0] = 100;
System.out.println(x[0]); // prints 100
```

Here, both `x` and `y` refer to the same array. Changes via one reference are reflected in the other.

### Method Parameter Behavior

- **Primitive types** are passed by value: a copy of the value is passed
- **Reference types** are also passed by value: a copy of the reference is passed

This means changes to object state are visible, but reassigning the reference inside the method does not affect the original.

**Example:**

```java
void modify(int x) {
    x = 100;
}

void modifyArray(int[] arr) {
    arr[0] = 100;
}
```

- `modify(primitive)` won't affect the original value
- `modifyArray(array)` will change the contents of the original array

### Special Case: String

- `String` is a reference type
- But it behaves like a value type because it is **immutable**
- Any operation on a `String` returns a new object

**Example:**

```java
String s1 = "Hello";
String s2 = s1;
s2 = "World";
System.out.println(s1); // prints "Hello"
```

Reassigning `s2` does not affect `s1`, even though they initially referred to the same string.

### Summary Comparison

| Feature                      | Value Type (Primitive)            | Reference Type (Object, Array)                 |
| ---------------------------- | --------------------------------- | ---------------------------------------------- |
| **Memory Location**          | Stack                             | Reference in Stack, Object in Heap             |
| **Stores**                   | Actual value                      | Memory address (reference)                     |
| **Assignment Behavior**      | Copies the value                  | Copies the reference                           |
| **Method Argument Behavior** | Pass-by-value (copy of value)     | Pass-by-value (copy of reference)              |
| **Garbage Collection**       | Not required                      | Managed by Java Garbage Collector              |
| **Example Types**            | `int`, `float`, `char`, `boolean` | `String`, `int[]`, `ArrayList`, custom objects |

## Stack vs Heap Memory

Understanding memory is crucial to understanding value vs reference types.

### Stack vs Heap Comparison

| Aspect                | Stack                                                                      | Heap                                               |
| --------------------- | -------------------------------------------------------------------------- | -------------------------------------------------- |
| **Purpose**           | Stores primitive values and references                                     | Stores object instances (actual data)              |
| **Memory location**   | Thread-local (each thread has its own stack)                               | Shared across all threads                          |
| **Speed**             | Very fast (LIFO access)                                                    | Slower due to dynamic allocation and GC            |
| **Memory management** | Automatically managed on method entry/exit                                 | Managed by Java's Garbage Collector                |
| **Lifetime**          | Lives as long as the method call                                           | Lives as long as references exist                  |
| **Thread safety**     | Thread-safe (no sharing between threads)                                   | Needs synchronization for shared access            |
| **Access type**       | Direct (fixed size, limited)                                               | Indirect (dynamic size, large pool)                |
| **Used for**          | - Primitive local variables<br>- References to objects                     | - All new objects<br>- Arrays<br>- Class instances |
| **Examples**          | `int x = 5;` (stored in stack)<br>`Person p = ...` (reference stored here) | `new Person("Alice")` (object lives in heap)       |
| **Cleanup**           | Popped off when method ends                                                | Collected by Garbage Collector                     |

### Memory Example

```java
int a = 10; // value type (stored in stack)
int[] arr = new int[3]; // reference type (reference in stack, array in heap)
arr[0] = 99;

int x = 5;
int y = x; // copies value

Book b1 = new Book("Java");
Book b2 = b1; // copies reference, both point to same object
```

## Incrementing Operations

### The Deep Dive

> Think of "pre" as "prepare" ‚Äî get the new value before using it  
> Think of "post" as "postpone" ‚Äî use now, change later

### Pre-increment vs Post-increment

| Form  | Effect                              | Example                                       |
| ----- | ----------------------------------- | --------------------------------------------- |
| `++x` | Increment first, then use the value | `int y = ++x;` ‚Üí x and y both incremented     |
| `x++` | Use the value, then increment       | `int y = x++;` ‚Üí y is old x, x is incremented |

**Example:**

```java
int x = 5;
int y = ++x; // x = 6, y = 6

x = 5;
y = x++; // x = 6, y = 5
```

### Special Case: Post-Increment in Expressions

Java evaluates `x++` using the original value, then increments it.

```java
int[] arr = {1, 2, 3};
int i = 0;
arr[i++] = 10;
```

**Result:**

- `arr[0]` becomes 10
- `i` becomes 1

Even though `i++` is in the array index, the index used is 0, and `i` is incremented after.

### Special Case: Boxed Types (e.g., Integer)

```java
Integer a = 100;
a++;
```

This works ‚Äî but here's what happens under the hood:

- `a++` unboxes `a` to an `int`
- Increments the value
- Boxes the result back into a new `Integer` object
- Assigns it back to `a`

So `a++` is syntactic sugar for:

```java
a = Integer.valueOf(a.intValue() + 1);
```

**Important:** Java caches `Integer` values from -128 to 127. Beyond that, boxing produces new objects.

```java
Integer x = 127;
Integer y = 127;
System.out.println(x == y); // true (cached)

x = 128;
y = 128;
System.out.println(x == y); // false (new objects)
```

### Summary Table

| Context                   | Behavior                                                             |
| ------------------------- | -------------------------------------------------------------------- |
| `int x = 5; x++`          | x becomes 6; value type directly modified                            |
| `Integer x = 5; x++`      | New Integer object created; x reassigned                             |
| `array[i++]`              | Uses i, then increments it                                           |
| `++x vs x++`              | Pre-increment changes value before use, post-increment changes after |
| Reference field increment | Affects all references to the object (if field is mutable)           |

## Strings

### 1. What is a String in Java?

- A String is a sequence of characters
- In Java, it is an **immutable** object of class `java.lang.String`
- Strings are reference types, but behave like value types because they're immutable

**Example:**

```java
String name = "Sree";
```

### 2. Why Are Strings Immutable?

- Once created, you cannot change the contents of a String
- Any modification (e.g., `.toUpperCase()`, `.concat()`) creates a new object
- Java uses immutability for security, thread safety, and performance optimizations like string pooling

**Example:**

```java
String a = "hello";
a.toUpperCase(); // returns "HELLO", but a is still "hello"
```

### 3. String Pool (Interning)

- Java maintains a pool of unique string literals in memory
- When you write `String x = "hello";`, it reuses the same object if it already exists

**Example:**

```java
String a = "hello";
String b = "hello";
System.out.println(a == b); // true (same reference from pool)

String c = new String("hello");
System.out.println(a == c); // false (new object)
```

### 4. Common String Methods

| Method                  | Description                              |
| ----------------------- | ---------------------------------------- |
| `length()`              | Returns number of characters             |
| `charAt(index)`         | Returns the character at specified index |
| `substring(start, end)` | Extracts a substring                     |
| `toUpperCase()`         | Converts to uppercase                    |
| `toLowerCase()`         | Converts to lowercase                    |
| `equals()`              | Compares string values (case-sensitive)  |
| `equalsIgnoreCase()`    | Compares values ignoring case            |
| `==`                    | Compares references (not values)         |
| `contains(str)`         | Checks if string contains another string |
| `replace(old, new)`     | Replaces occurrences of a substring      |
| `split(delimiter)`      | Splits string into an array              |
| `trim()`                | Removes leading/trailing spaces          |

### 5. Common Pitfalls

#### Using == vs .equals()

```java
String a = new String("hello");
String b = new String("hello");

System.out.println(a == b);        // false
System.out.println(a.equals(b));   // true
```

#### Null Safety

```java
String s = null;
// s.equals("test");    // throws NullPointerException
"test".equals(s);       // safe
```

### Practice Exercises

#### Exercise 1: Pooling and Equality

```java
String a = "Java";
String b = "Java";
String c = new String("Java");
System.out.println(a == b);      // true
System.out.println(a == c);      // false
System.out.println(a.equals(c)); // true
```

#### Exercise 2: Immutability Check

```java
String original = "start";
original.concat("end");
System.out.println(original); // prints "start"
```

#### Exercise 3: Reversing a String

Write a method that takes a string and returns its reverse.

```java
String reverse(String input) {
    // implement logic here
}
// Input: "hello" ‚Üí Output: "olleh"
```

#### Exercise 4: Count Vowels

Count the number of vowels in:

```java
String sentence = "Programming is powerful";
```

#### Exercise 5: Split and Extract Key-Value

Given:

```java
String data = "user=admin;password=1234";
```

Extract and print:

- Username: admin
- Password: 1234

## Pass-by-Value vs Pass-by-Reference

### Key Concept

**Java always uses pass-by-value.**

However, it's important to distinguish between:

- **Primitives**: The actual value is passed
- **Objects**: A copy of the reference is passed

So while Java is technically always pass-by-value, the behavior with objects can look like pass-by-reference.

### Pass-by-Value (Primitives)

When a primitive variable is passed to a method:

- A copy of its value is made
- Modifying this copy does not affect the original variable

```java
void update(int a) {
    a = 10;
}

int x = 5;
update(x);
System.out.println(x); // Output: 5
```

### Pass-by-Value (Object References)

When an object is passed:

- A copy of the reference (pointer) is passed
- Both the original and the copy point to the same object in memory
- You can change the object's contents inside the method
- But you cannot change the caller's reference to point to a new object

```java
class Book {
    String title;
    Book(String title) { this.title = title; }
}

void update(Book b) {
    b.title = "Updated";     // affects original object
    b = new Book("New");     // only affects local reference
}

Book myBook = new Book("Original");
update(myBook);
System.out.println(myBook.title); // Output: Updated
```

### Summary Table

| Concept                        | Primitives   | Object References                  |
| ------------------------------ | ------------ | ---------------------------------- |
| **What is passed**             | Actual value | Copy of the reference              |
| **Can modify original value?** | No           | Yes (object state)                 |
| **Can reassign reference?**    | N/A          | No (only the local copy)           |
| **Stored in**                  | Stack        | Reference in stack, object in heap |

### Analogy: Room Key

Think of objects as hotel rooms and references as keys:

- Java hands over a copy of the key (reference) to a method
- The method can use the key to modify the room
- But giving it a new key (reassigning) won't change the caller's original key

## Practice Code Examples

Below are the practical examples from the original codebase demonstrating various Java concepts:

### Test Classes for Increment Operations

```java
package com.reference;

class Test1 {
    void runTest1() {
        int x = 10;
        int y = x++;  // y = 10, x = 11
        int z = ++x;  // z = 12, x = 12
        System.out.println("Test 1");
        System.out.println("x = " + x); // x = 12
        System.out.println("y = " + y); // y = 10
        System.out.println("z = " + z); // z = 12
    }
}

class Test2 {
    void runTest2() {
        int a = 3;
        System.out.println("Test 2");
        System.out.println("val = " + a++); // prints 3, then a becomes 4
    }
}

class Test3 {
    void runTest3() {
        System.out.println("Test 3");
        int[] arr = new int[3]; // [0,0,0]
        int i = 0;
        arr[i++] = 1; // [1,0,0] i = 1
        arr[i++] = 2; // [1,2,0] i = 2
        arr[i] = 3;   // [1,2,3] i = 2
        System.out.println(java.util.Arrays.toString(arr));
    }
}

class Counter {
    int count = 0;
}

class Test4 {
    void runTest4() {
        System.out.println("Test 4");
        Counter c1 = new Counter();
        Counter c2 = c1; // both refer to the same object
        c1.count++; // c1.count = 1
        c2.count++; // c2.count = 2; also updates c1.count to 2
        System.out.println("c1.count = " + c1.count); // 2
        System.out.println("c2.count = " + c2.count); // 2
    }
}

class Test5 {
    void runTest5() {
        System.out.println("Test 5");
        int x = 1;
        int result = x++ + x++ + x;
        // 1 (use 1, then increment to 2) + 2 (use 2, then increment to 3) + 3 (use 3) = 6
        System.out.println("result = " + result); // result = 6
        System.out.println("final x = " + x);     // final x = 3
    }
}

public class Main {
    /**
     * This is the comment that is going in for the main
     *
     * @param args command line arguments
     */
    public static void main(String[] args) {
        System.out.println("Amigos Code");

        Test1 test1 = new Test1();
        test1.runTest1();

        Test2 test2 = new Test2();
        test2.runTest2();

        Test3 test3 = new Test3();
        test3.runTest3();

        Test4 test4 = new Test4();
        test4.runTest4();

        Test5 test5 = new Test5();
        test5.runTest5();
    }
}
```

---

## License

This document is created for educational purposes. Feel free to use and modify as needed for your Java learning journey.

## Contributing

If you find any errors or have suggestions for improvements, please feel free to contribute by submitting issues or pull requests.
